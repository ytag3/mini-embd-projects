/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 */

#include <stdio.h>
#include "main.h"
#include "led.h"


// ----- PROTOTYPES -----

extern void initialise_monitor_handles(void); //semihosting init funct

//User Tasks
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);

void enable_processor_faults(void);
__attribute__((naked)) void init_scheduler_stack(uint32_t sched_stack_top);
void init_task_stack(void);
void init_systick_timer(uint32_t tick_freq);

void schedule(void); 
void task_delay(uint32_t tick_count);
void idle_handler(void);  
void update_global_tick_count(void);

uint32_t get_psp_value(void);
void save_psp_value(uint32_t stack_addr); 
__attribute__((naked)) void switch_sp_to_psp(void);
void update_next_task(void); 
void SysTick_Handler(void); 



// ----- VARIABLES -----
uint32_t g_tick_count = 0; //controlled by schedulure
uint8_t current_task = 1; //task1 running

typedef struct{
	uint32_t 	psp_value; //private stack pointer for tasks
	uint32_t 	block_count;
	uint8_t 	current_state;
	void		(*task_handler)(void); //task handler address
}TCB_t;

TCB_t user_tasks[MAX_TASKS];


int main(void)
{
	enable_processor_faults();

	initialise_monitor_handles();

	init_scheduler_stack(SCHED_STACK_START);

	printf("Implementation of simple task scheduler\n");

	init_task_stack();
	led_init_all();
	init_systick_timer(TICK_HZ);

	switch_sp_to_psp();
	task1_handler();
	for(;;); //loop forever
}

// -- Handlers and Functions --

//user tasks
void task1_handler(void){
	while(1){
		printf("Task 1\n");
		led_on(LED_GREEN);
		task_delay(1000);
		led_off(LED_GREEN);
		task_delay(1000);
	}
}
void task2_handler(void){
	while(1){
		printf("Task 2\n");
		led_on(LED_ORANGE);
		task_delay(500);
		led_off(LED_ORANGE);
		task_delay(500);
	}
}
void task3_handler(void){
	while(1){
		printf("Task 3\n");
		led_on(LED_BLUE);
		task_delay(250);
		led_off(LED_BLUE);
		task_delay(250);
	}
}
void task4_handler(void){
	while(1){
		printf("Task 4\n");
		led_on(LED_RED);
		task_delay(125);
		led_off(LED_RED);
		task_delay(125);
	}
}
void idle_handler(void){ //always in running state, is task 0, always run if everything is blocked
	printf("Idle \n");
	while(1);
}


//for more detail when debugging
void enable_processor_faults(void){
	uint32_t *pSHCSR = (uint32_t*)CONF_FAULT_REG;

	*pSHCSR |= (1 << 16); //mem manage
	*pSHCSR |= (1 << 17); //bus fault
	*pSHCSR |= (1 << 18); //usage fault

}

//change value of MSP here to control flow of program
__attribute__((naked)) void init_scheduler_stack(uint32_t sched_stack_top){
    	__asm volatile("MSR MSP,%0": :  "r" (sched_stack_top)  :   ); 
	__asm volatile("BX LR"); //indirect branch to return function
}

//used to initialize tasks for scheduling
void init_task_stack(void){

	user_tasks[0].psp_value = IDLE_STACK_START;
	user_tasks[1].psp_value = T1_STACK_START;
	user_tasks[2].psp_value = T2_STACK_START;
	user_tasks[3].psp_value = T3_STACK_START;
	user_tasks[4].psp_value = T4_STACK_START;

	user_tasks[0].task_handler = idle_handler;
	user_tasks[1].task_handler = task1_handler;
	user_tasks[2].task_handler = task2_handler;
	user_tasks[3].task_handler = task3_handler;
	user_tasks[4].task_handler = task4_handler;

	user_tasks[0].current_state = TASK_RUNNING_STATE; //NOTE: fixed this from task handler to current state
	user_tasks[1].current_state = TASK_RUNNING_STATE;
	user_tasks[2].current_state = TASK_RUNNING_STATE;
	user_tasks[3].current_state = TASK_RUNNING_STATE;
	user_tasks[4].current_state = TASK_RUNNING_STATE;

	uint32_t *pPSP; //walk down each private stack to store values for context
	for(int i = 0; i < MAX_TASKS; i++){

		pPSP = (uint32_t*) user_tasks[i].psp_value;

		//start of stack

		//fill initial context of special registers
		pPSP--;
		*pPSP = INIT_XPSR;

		pPSP--; //PC
		*pPSP = (uint32_t)user_tasks[i].task_handler; //Note: Double semicolon here

		pPSP--; //LR
		*pPSP = INIT_LR;

		//fill initial context of registers R13 to R0
		for(int j = 0; j<13; j++){
			pPSP--;
			*pPSP = 0;
		}
		user_tasks[i].psp_value = (uint32_t)pPSP; //update pointer for remaining of private stack
	}
}

//initializes timer based on desired tick frequency
void init_systick_timer(uint32_t tick_freq){
	uint32_t *pSRVR = (uint32_t*)SYSTICK_SVR_REG;
	uint32_t *pSCSR = (uint32_t*)SYSTICK_CSR_REG;
	uint32_t count_value = (SYSTICK_TIM_CLK/tick_freq)-1; //based on datasheet rec N-1

	//set reload value using SVR reg
	*pSRVR &= ~(0x00FFFFFFFF); //clear 24bit value. 00 is reserved bits
	*pSRVR |= count_value; //load

	//configure timer using CSR reg
	*pSCSR |= (1<<1); //enable systick exception request
	*pSCSR |= (1<<2); //set clock source to processor clock
	*pSCSR |= (1<<0); //enable systick clock
}

void schedule(void){
	uint32_t *pICSR = (uint32_t*)ICSR_REG;
	*pICSR |= (1 << 28); //pend PendSV
}

void task_delay(uint32_t tick_count){
	//avoid race condition by disable and enable interrupt
	INTERRUPT_DISABLE(); //not good for crit systems

	if(current_task){ //if idling
		user_tasks[current_task].block_count = g_tick_count + tick_count;
		user_tasks[current_task].current_state = TASK_BLOCKED_STATE;
		schedule(); //switch to next running task
	}
	INTERRUPT_ENABLE(); //not good for crit systems
}

uint32_t get_psp_value(void){
	return user_tasks[current_task].psp_value;
}

void save_psp_value(uint32_t current_psp){
	user_tasks[current_task].psp_value = current_psp;
}

__attribute__((naked)) void switch_sp_to_psp(void){
	// initialize PSP w task1 stack start address
	__asm volatile("PUSH {LR}"); //store return address for main (LR)
	__asm volatile("BL get_psp_value"); //branch with link(return) to pther function, stored psp in R0 due to procedure call standard, corrupts LR
	__asm volatile("MSR PSP, R0"); //set PSP to value of R0
	__asm volatile("POP {LR}");

	// change sp to psp using control reg
	__asm volatile("MOV R0, #0x02"); //bit
	__asm volatile("MSR CONTROL, R0"); //set control reg to psp
	__asm volatile ("BX LR");
}

//round robin implementation W idle task and task state
void update_next_task(void){

	int state = TASK_BLOCKED_STATE; //initialized to blocked, so stays blocked unless updated otherwise

	for(int i = 0; i < (MAX_TASKS); i++){ //check for blocked tasks
		current_task++;
		current_task %= MAX_TASKS; //between 1=4
		state = user_tasks[current_task].current_state; //NOTE: fixed this from i to current task
		if ((state == TASK_RUNNING_STATE) && (current_task !=0))
			 break; //if user task is ready, then....
	}
	if (state != TASK_RUNNING_STATE) 
		current_task = 0; //if still blocked

}

void update_global_tick_count(void){
	g_tick_count++;
}

void unblock_tasks(){
	for (int i = 1; i < MAX_TASKS; i++){
		if(user_tasks[i].current_state != TASK_RUNNING_STATE){
			if(user_tasks[i].block_count == g_tick_count){
				user_tasks[i].current_state = TASK_RUNNING_STATE;
			}
		}
	}

}

void SysTick_Handler(void){
	uint32_t *pICSR = (uint32_t*)ICSR_REG;

	update_global_tick_count();
	unblock_tasks();

	*pICSR |= (1 << 28); //pend PendSV
}

//context switching
__attribute((naked)) void PendSV_Handler(void){

	/*save context of current task1*/
	__asm volatile("MRS R0, PSP"); //get current running task PSP value
	__asm volatile("STMDB R0!, {R4-R11}");//store context leftover using PSP, cant use push since handler is MSP, store registers, decrement before
	__asm volatile("PUSH {LR}"); //store current LR so that execution exits
	__asm volatile("BL save_psp_value"); //save current value of PSP fir later

	/*retrieve context of next task*/
	__asm volatile("BL update_next_task");//decide next task to run
	__asm volatile("BL get_psp_value"); //get previous PSP value for next task
	__asm volatile("LDMIA R0!,{R4-R11} "); //use PSP to retrieve R4 to R11, increment after

	/*exit into next task*/
	__asm volatile("MSR PSP, R0");  //update PSP to addr of next task to execute
	__asm volatile("POP {LR}");
	__asm volatile("BX LR"); //naked funct so exit manually
}

void HardFault_Handler(void){
	printf("Exception: HardFault\n");
	while(1);
}
void MemManage_Handler(void){
	printf("Exception: MemManage\n");
	while(1);
}
void BusFault_Handler(void){
	printf("Exception: BusFault\n");
	while(1);
}
